<!doctype html>
<html lang="es">
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>C√≥digo idiom√°tico - Fernando Silva Jacquier</title>

		<link rel="stylesheet" href="dist/reset.css">
		<link rel="stylesheet" href="dist/reveal.css">
		<link rel="stylesheet" href="dist/theme/solarized.css">

		<!-- Theme used for syntax highlighted code -->
		<link rel="stylesheet" href="plugin/highlight/monokai.css">
	</head>
	<body>
		<div class="reveal">
			<div class="slides">

				<!-- ============================================ -->
				<!-- COLUMNA 1: INTRODUCCI√ìN                      -->
				<!-- ============================================ -->
				<section>
					<!-- Slide 1.1: T√≠tulo principal -->
					<section>
						<h1 class="fragment">C√≥digo idiom√°tico</h1>
						<h3 class="fragment">El valor de poder decir lo mismo de muchas maneras</h3>
						<h3 class="fragment">y la importancia de decirlo de la manera correcta</h3>
						<p class="fragment">
							<small>Fernando Silva Jacquier</small>
						</p>
						<aside class="notes">
							[SPEAKER NOTES: Introducci√≥n personal, contexto del grupo Ruby local, expectativas de la charla]
						</aside>
					</section>

					<!-- Slide 1.2: Tres formas de presentarse -->
					<section>
						<h2>Una historia sobre opciones</h2>
						<div class="fragment">
							<h3>Yo soy Fernando</h3>
						</div>
						<div class="fragment">
							<h3>Mi nombre es Fernando</h3>
						</div>
						<div class="fragment">
							<h3>Me llamo Fernando</h3>
						</div>
						<aside class="notes">
							Son distintas formas de expresar lo mismo.

							Tal vez, sin darme cuenta, el contexto define cu√°l elijo. A un hablante de una lengua sajona podr√≠a decirle "Mi nombre es Fernando" (cercano a "My name is Fernando"), pero a un hablante de una lengua romance podr√≠a decirle "Me llamo Fernando" (cercano a "Je m'appelle Fernando").

							Anticipar que volveremos a esto al final para cerrar el c√≠rculo.
						</aside>
					</section>

					<!-- Slide 1.3: El concepto -->
					<section>
						<h2>Lo mismo, de distintas maneras</h2>
						<p class="fragment">En el lenguaje natural tenemos m√∫ltiples formas de expresar la misma idea</p>
						<p class="fragment">En programaci√≥n, especialmente en Ruby, tambi√©n</p>
						<p class="fragment">¬øEs esto bueno o malo?</p>
						<aside class="notes">
							Con el c√≥digo, es parecido.

							Hay ocasiones en las que una manera de expresar algo es mejor que otra debido al contexto.

							Esta es la tensi√≥n central de la charla: m√∫ltiples opciones pueden ser problem√°ticas, pero tambi√©n valiosas.
						</aside>
					</section>
				</section>

				<!-- ============================================ -->
				<!-- COLUMNA 2: EL PROBLEMA                       -->
				<!-- ============================================ -->
				<section>
					<!-- Slide 2.1: El problema que motiv√≥ la charla -->
					<section>
						<h2>El problema que dispar√≥ esta charla</h2>
						<p class="fragment">Un amigo ten√≠a un problema de memoria en producci√≥n</p>
						<aside class="notes">
							[SPEAKER NOTES: Contextualizar el problema real que motiv√≥ la charla. Hablar del memory bloat.]
						</aside>
					</section>

					<!-- Slide 2.2: El c√≥digo problem√°tico -->
					<section>
						<h2>Memory bloat</h2>
						<pre><code data-trim data-noescape class="language-ruby">
# ‚ùå Carga TODOS los usuarios en memoria
User.all.each do
  UserMailer.with(user: it).payment_reminder.deliver_later
end

<span class="fragment"># ‚úÖ Procesa en batches de 1000
User.find_each do |user|
  UserMailer.with(user: user).payment_reminder.deliver_later
end</span>
						</code></pre>
						<aside class="notes">
							El c√≥mo puede ser tan importante como el qu√©.

							.each carga todos los registros en memoria de una sola vez. Con 100K usuarios, esto puede significar varios GB de RAM.

							.find_each procesa en batches de 1000. Carga 1000, procesa, libera memoria, carga los siguientes 1000.

							Nota: Ruby 3.4 introduce "it" como variable de bloque impl√≠cita.
						</aside>
					</section>

					<!-- Slide 2.2b: Memory profiler example (TODO) -->
					<section>
						<h2>Midiendo el impacto real</h2>
						<p class="fragment">TODO: Agregar ejemplo con memory_profiler</p>
						<pre class="fragment"><code data-trim data-noescape class="language-ruby">
# Ejemplo con memory_profiler mostrando:
# - Memory allocations para .each
# - Memory allocations para .find_each
# - Diferencia en MB/GB
						</code></pre>
						<aside class="notes">
							TODO: Ejecutar memory_profiler en ambos casos y mostrar resultados reales.

							Mostrar:
							- Total memory allocated
							- Total memory retained
							- Peak memory usage
						</aside>
					</section>

					<!-- Slide 2.2c: Work distribution graph (TODO) -->
					<section>
						<h2>Distribuci√≥n del trabajo</h2>
						<p class="fragment">TODO: Agregar gr√°fico de distribuci√≥n del trabajo</p>
						<div class="fragment">
							<p>Visualizaci√≥n comparando:</p>
							<ul>
								<li>.each: Un bloque monol√≠tico de memoria</li>
								<li>.find_each: M√∫ltiples bloques peque√±os con GC entre medio</li>
							</ul>
						</div>
						<aside class="notes">
							TODO: Crear gr√°fico mostrando timeline de:
							- Uso de memoria a lo largo del tiempo
							- Puntos donde el GC puede actuar con find_each
							- Por qu√© .each no permite GC hasta el final
						</aside>
					</section>

					<!-- Slide 2.3: present? vs exist? vs any? -->
					<section>
						<h2>Muchas formas de verificar existencia</h2>
						<pre><code data-trim data-noescape class="language-ruby">
<span class="fragment"># ¬øCu√°l usar√≠as?
User.where(active: true).present?</span>
<span class="fragment">User.where(active: true).exists?</span>
<span class="fragment">User.where(active: true).any?</span>
						</code></pre>
						<aside class="notes">
							[SPEAKER NOTES: Explicar las diferencias sutiles entre estos m√©todos en t√©rminos de qu√© hacen internamente.]
						</aside>
					</section>

					<!-- Slide 2.4: Qu√© vs C√≥mo -->
					<section>
						<h2>La diferencia: ¬øQu√© vs C√≥mo?</h2>
						<pre><code data-trim data-noescape class="language-ruby">
# present? ‚Üí Carga registros y verifica en Ruby
User.where(active: true).present?
# SELECT * FROM users WHERE active = true

<span class="fragment"># exists? ‚Üí Pregunta directamente a la DB
User.where(active: true).exists?
# SELECT 1 FROM users WHERE active = true LIMIT 1</span>

<span class="fragment"># any? ‚Üí Puede usar cualquiera de las dos estrategias
User.where(active: true).any?</span>
						</code></pre>
						<aside class="notes">
							Profundizar en c√≥mo cada m√©todo implementa la verificaci√≥n.

							present?: Materializa todos los registros en memoria, luego verifica si el array est√° vac√≠o
							exists?: Solo pregunta a la DB "¬øhay al menos 1?", no trae datos
							any?: Depende del contexto - puede usar la estrategia de present? o exists?

							Mostrar las queries SQL reales para evidenciar la diferencia.
						</aside>
					</section>

					<!-- Slide 2.4b: Memory profiler comparison (TODO) -->
					<section>
						<h2>El costo real de cada opci√≥n</h2>
						<p class="fragment">TODO: Agregar ejemplo con memory_profiler</p>
						<pre class="fragment"><code data-trim data-noescape class="language-ruby">
# Comparaci√≥n de memory allocations:
# User.where(active: true).present?
# vs
# User.where(active: true).exists?
#
# Mostrar diferencia en MB especialmente con muchos registros
						</code></pre>
						<aside class="notes">
							TODO: Ejecutar memory_profiler comparando present? vs exists? con diferentes vol√∫menes de datos.

							Mostrar c√≥mo present? escala linealmente con la cantidad de registros, mientras exists? es O(1).
						</aside>
					</section>

					<!-- Slide 2.4c: Real-world view example (TODO) -->
					<section>
						<h2>Caso real: Contador de emails no le√≠dos</h2>
						<p class="fragment">TODO: Agregar snippet de vista HTML.ERB</p>
						<pre class="fragment"><code data-trim data-noescape class="language-erb">
&lt;%# app/views/layouts/_header.html.erb %&gt;
&lt;div class="inbox-counter"&gt;
  &lt;% if @unread_emails.present? %&gt;
    &lt;span class="badge"&gt;&lt;%= @unread_emails.count %&gt;&lt;/span&gt;
  &lt;% end %&gt;
&lt;/div&gt;

&lt;!-- ¬øQu√© query genera esto? --&gt;
						</code></pre>
						<aside class="notes">
							TODO: Mostrar ejemplo de contador tipo Gmail.

							Este patr√≥n com√∫n puede causar N+1 queries o cargar datos innecesarios.

							Alternativas m√°s eficientes:
							- exists? para el check
							- counter_cache o SQL COUNT para el n√∫mero
						</aside>
					</section>

					<!-- Slide 2.5: Enumerable#all? y vacuous truth -->
					<section>
						<h2>Un caso peculiar: all?</h2>
						<pre><code data-trim data-noescape class="language-ruby">
<span class="fragment">[].all? { |x| x > 100 }
# => true ü§î</span>

<span class="fragment"># Vacuous truth: verdad vacua
# "Todos los elementos cumplen la condici√≥n"
# ...porque no hay elementos que la violen</span>
						</code></pre>
						<aside class="notes">
							[SPEAKER NOTES: Explicar el concepto de vacuous truth de l√≥gica formal. Conectar con neutral elements: AND ‚Üí true, suma ‚Üí 0, producto ‚Üí 1.]
						</aside>
					</section>

					<!-- Slide 2.6: ¬øPor qu√© esto es confuso? -->
					<section>
						<h2>El peligro de la verdad vacua</h2>
						<pre><code data-trim data-noescape class="language-ruby">
def all_users_are_adults?(users)
  users.all? { |u| u.age >= 18 }
end

<span class="fragment"># ¬øQu√© pasa si no hay usuarios?
all_users_are_adults?([])  # => true

# "Todos los usuarios son adultos"
# pero... ¬°no hay usuarios!</span>
						</code></pre>
						<aside class="notes">
							[SPEAKER NOTES: Mostrar c√≥mo esto puede llevar a bugs sutiles. Distinguir entre lenguaje natural (presupone dominio no-vac√≠o) y l√≥gica formal.]
						</aside>
					</section>

					<!-- Slide 2.7: Resumen de la secci√≥n -->
					<section>
						<h2>Entonces...</h2>
						<p class="fragment">Tener m√∫ltiples formas de decir lo mismo puede causar problemas</p>
						<p class="fragment">Diferencias sutiles en implementaci√≥n</p>
						<p class="fragment">Comportamientos contra-intuitivos</p>
						<p class="fragment">Bugs en producci√≥n</p>
						<aside class="notes">
							[SPEAKER NOTES: Transici√≥n a la siguiente secci√≥n. Plantear la pregunta: entonces ¬øpor qu√© Ruby nos da tantas opciones?]
						</aside>
					</section>
				</section>

				<!-- ============================================ -->
				<!-- COLUMNA 3: EL VALOR                          -->
				<!-- ============================================ -->
				<section>
					<!-- Slide 3.1: Intro al valor -->
					<section>
						<h2>¬øPor qu√© tantas opciones?</h2>
						<p class="fragment">Si las opciones causan problemas...</p>
						<p class="fragment">¬øPor qu√© Ruby nos da tantas?</p>
						<p class="fragment">Debe haber un valor</p>
						<aside class="notes">
							[SPEAKER NOTES: Cambio de perspectiva. Ahora vamos a ver el lado positivo de tener m√∫ltiples opciones.]
						</aside>
					</section>

					<!-- Slide 3.2: Feedback loops -->
					<section>
						<h2>Ciclos de retroalimentaci√≥n cortos</h2>
						<p class="fragment">Los desarrolladores hacen ~200 micro-feedback loops por d√≠a</p>
						<p class="fragment">Idea ‚Üí C√≥digo ‚Üí Validaci√≥n ‚Üí Refinamiento</p>
						<p class="fragment">Cuanto m√°s corto el ciclo, m√°s productivos somos</p>
						<aside class="notes">
							[SPEAKER NOTES: Citar el research de 2024-2025 sobre feedback loops y productividad. Mencionar estudios de eBay, Spotify sobre cognitive load.]
						</aside>
					</section>

					<!-- Slide 3.3: C√≥digo idiom√°tico reduce fricci√≥n -->
					<section>
						<h2>Expresividad = Menos fricci√≥n cognitiva</h2>
						<pre><code data-trim data-noescape class="language-ruby">
<span class="fragment"># Lo que piensas:
# "Para cada usuario activo..."
users.where(active: true).each do |user|
  # ...
end</span>

<span class="fragment"># vs en un lenguaje menos expresivo:
# "Inicializar iterador sobre colecci√≥n filtrada..."
iterator = users.filter(lambda u: u.active == True)
for user in iterator:
  # ...</span>
						</code></pre>
						<aside class="notes">
							Ruby reduce la "distancia cognitiva" entre pensamiento y c√≥digo.

							Estudio MIT (2020): Comprender c√≥digo activa principalmente redes cerebrales de resoluci√≥n de problemas, NO las √°reas de procesamiento de lenguaje natural. Programar se asemeja m√°s a resolver un rompecabezas que a leer texto.

							Por eso, lenguajes con sintaxis intuitiva y cercana a c√≥mo pensamos los algoritmos acortan el puente entre intenci√≥n y c√≥digo escrito.

							Filosof√≠a de Matz: "designed to make programmers happy" - hacer m√°s f√°cil el trabajo del humano a costa de que el runtime cargue con m√°s trabajo.
						</aside>
					</section>

					<!-- Slide 3.4: El costo de la traducci√≥n -->
					<section>
						<h2>El costo de traducir pensamiento a c√≥digo</h2>
						<p class="fragment">En una feature peque√±a: 10-20 ciclos de traducci√≥n</p>
						<p class="fragment">En una feature mediana: 100-200 ciclos</p>
						<p class="fragment">En una feature grande: 1000+ ciclos</p>
						<p class="fragment">Cada ciclo con fricci√≥n = tiempo y energ√≠a mental perdida</p>
						<p class="fragment"><em>Cuanto m√°s similar a "pensamiento natural" sea el c√≥digo, menos carga cognitiva</em></p>
						<aside class="notes">
							Hacer el argumento cuantitativo: Si cada traducci√≥n toma 5 segundos extra, en 1000 ciclos = ~1.5 horas perdidas.

							El estudio MIT confirma: como programar activa redes de resoluci√≥n de problemas (no lenguaje), la sintaxis intuitiva acelera el mapeo mental.

							Ruby's high-level abstractions reducen pasos intermedios entre "lo que quiero hacer" y "c√≥mo se escribe".
						</aside>
					</section>

					<!-- Slide 3.4b: Expresividad en acci√≥n -->
					<section>
						<h2>Expresividad en acci√≥n</h2>
						<pre><code data-trim data-noescape class="language-ruby">
<span class="fragment"># ‚ùå Forma ceremonial
if !user.admin?
  redirect_to root_url
end</span>

<span class="fragment"># ‚úÖ Expresivo, casi lenguaje natural
redirect_to root_url unless user.admin?
# "Redirigir... a menos que usuario sea admin"</span>
						</code></pre>
						<pre class="fragment"><code data-trim data-noescape class="language-ruby">
# ‚ùå Iteraci√≥n manual
user_ids = []
users.each { |u| user_ids << u.id }

<span class="fragment"># ‚úÖ Idiom√°tico, una l√≠nea
user_ids = users.map(&:id)</span>
						</code></pre>
						<aside class="notes">
							Estos ejemplos ilustran la diferencia entre c√≥digo funcional y c√≥digo expresivo.

							unless: Se lee como lenguaje cotidiano. En espa√±ol: "a menos que". En ingl√©s: "unless". Natural.

							map(&:id): S√≠mbolo to_proc. Compacto pero claro. vs iteraci√≥n manual que requiere variable temporal y m√∫ltiples l√≠neas.

							DHH: "Ruby es lo opuesto a Python (una forma obvia). Hay muchas formas de hacer casi cualquier cosa, y por eso leer y escribir Ruby es un deleite."
						</aside>
					</section>

					<!-- Slide 3.5: Ruby's philosophy -->
					<section>
						<h2>La filosof√≠a de Ruby</h2>
						<blockquote class="fragment">
							"Ruby is designed to make programmers happy"
							<br>‚Äî Yukihiro "Matz" Matsumoto
						</blockquote>
						<p class="fragment">Lenguaje de alto nivel</p>
						<p class="fragment">Expresivo y cercano al lenguaje natural</p>
						<p class="fragment">Optimizado para ser le√≠do y entendido</p>
						<p class="fragment"><strong>Principio de la Menor Sorpresa:</strong> c√≥digo predecible reduce sorpresas</p>
						<aside class="notes">
							Contextualizar la filosof√≠a de dise√±o de Ruby. El c√≥digo se lee m√°s que se escribe.

							Principio de la Menor Sorpresa (POLA): usando la sintaxis y estructuras que la comunidad espera, el c√≥digo comunica su intenci√≥n sin distraer con formas inusuales.

							Gusto Engineering: "Usar sintaxis com√∫n evita distraer del prop√≥sito del c√≥digo; las desviaciones saltan a la vista, as√≠ que m√°s vale que sean intencionales."

							DHH: "El mejor c√≥digo Ruby se acerca a una forma de poes√≠a: cada desarrollador puede desarrollar su estilo, dentro de la riqueza expresiva del lenguaje."

							C√≥digo idiom√°tico = predecible = mantenible = feliz
						</aside>
					</section>

					<!-- Slide 3.5b: Ruby a escala: casos reales -->
					<section>
						<h2>Ruby a escala: casos reales</h2>
						<div class="fragment">
							<h3>Shopify</h3>
							<p><em>"Rails permite enviar funcionalidades r√°pido sin ahogarse en boilerplate"</em></p>
							<p><small>Billion-dollar scale con Ruby on Rails</small></p>
						</div>
						<div class="fragment">
							<h3>Basecamp</h3>
							<p><em>"Escribir c√≥digo menos precioso y m√°s exploratorio"</em></p>
							<p><small>Spikes y prototipos en Ruby para validar enfoques</small></p>
						</div>
						<div class="fragment">
							<p><strong>Estos no son juguetes. Son sistemas sirviendo millones de requests.</strong></p>
						</div>
						<aside class="notes">
							Shopify: "Las convenciones opinadas permiten a los ingenieros enviar funcionalidades r√°pido sin ahogarse en boilerplate. Rails te permite enfocarte en el comercio, no en la plomer√≠a."

							Basecamp (equipo de DHH): Hacen peque√±os spikes o prototipos para responder preguntas puntuales antes de formalizar funcionalidades. Aprovechan la baja fricci√≥n de Ruby.

							Estos ejemplos destruyen el mito de "Ruby no escala". El problema nunca fue Ruby, son las arquitecturas mal dise√±adas.

							La expresividad de Ruby les permite iterar m√°s r√°pido, mantener c√≥digo m√°s limpio, y atraer mejores desarrolladores.
						</aside>
					</section>

					<!-- Slide 3.6: Divergencia y convergencia -->
					<section>
						<h2>Divergir y converger</h2>
						<p class="fragment">M√∫ltiples opciones permiten <strong>divergencia</strong></p>
						<p class="fragment">Explorar r√°pidamente diferentes bocetos de tu idea</p>
						<p class="fragment">Comparar alternativas sin commitment</p>
						<p class="fragment">Luego converger hacia la mejor soluci√≥n</p>
						<aside class="notes">
							[SPEAKER NOTES: Explicar design thinking aplicado a c√≥digo. Citar research sobre divergent/convergent thinking en desarrollo de software.]
						</aside>
					</section>

					<!-- Slide 3.7: Riffing -->
					<section>
						<h2>Ejemplo: Riffing</h2>
						<p class="fragment">T√©cnica de Kasper Timm Hansen (Rails Core Team)</p>
						<p class="fragment">"Wireframing para c√≥digo"</p>
						<pre class="fragment"><code data-trim data-noescape class="language-ruby">
# En un scratch file:
class UserNotifier
  def notify_all
    users.where(active: true).find_each do |user|
      # ... o tal vez ...
    end

    # users.active.find_each do |user|
    #   ...
    # end
  end
end
						</code></pre>
						<aside class="notes">
							[SPEAKER NOTES: Explicar el riffing: escribir c√≥digo casi-ejecutable en un scratch file para explorar dise√±o sin distracciones. Iterar r√°pido, probar alternativas.]
						</aside>
					</section>

					<!-- Slide 3.8: M√°s beneficios -->
					<section>
						<h2>Otros beneficios</h2>
						<ul>
							<li class="fragment">Convention over Configuration libera de decisiones triviales</li>
							<li class="fragment">Permite diferentes niveles de abstracci√≥n seg√∫n contexto</li>
							<li class="fragment">Facilita refactoring gradual</li>
							<li class="fragment">Reduce barreras de entrada (escribes "como piensas")</li>
							<li class="fragment">C√≥digo m√°s mantenible cuando se elige bien</li>
						</ul>
						<aside class="notes">
							Convention over Configuration (Rails doctrine): No decides una y otra vez sobre detalles triviales. El framework provee un "camino feliz" para funcionalidades comunes.

							Esto acelera los ciclos de retroalimentaci√≥n: escribes c√≥digo y lo ves ejecutarse r√°pidamente, ideal para iterar.

							M√∫ltiples niveles de abstracci√≥n: puedes escribir c√≥digo de alto nivel para prototipar, y bajar de nivel cuando necesites optimizar.

							El punto clave: las opciones son valiosas cuando se usan con criterio.
						</aside>
					</section>

					<!-- Slide 3.9: Resumen del valor -->
					<section>
						<h2>El valor de m√∫ltiples opciones</h2>
						<p class="fragment">‚úÖ Feedback loops m√°s cortos</p>
						<p class="fragment">‚úÖ Menos fricci√≥n cognitiva</p>
						<p class="fragment">‚úÖ Divergencia y convergencia</p>
						<p class="fragment">‚úÖ Expresividad y mantenibilidad</p>
						<aside class="notes">
							[SPEAKER NOTES: Transici√≥n: Hemos visto los problemas y el valor. Ahora la pregunta cr√≠tica: ¬øc√≥mo elegir bien?]
						</aside>
					</section>
				</section>

				<!-- ============================================ -->
				<!-- COLUMNA 4: CONVERGENCIA                      -->
				<!-- ============================================ -->
				<section>
					<!-- Slide 4.1: Intro -->
					<section>
						<h2>Entonces, ¬øc√≥mo elegir?</h2>
						<p class="fragment">Vimos que las opciones pueden causar problemas</p>
						<p class="fragment">Vimos que las opciones aportan valor</p>
						<p class="fragment">La clave est√° en <strong>converger hacia la opci√≥n correcta</strong></p>
						<aside class="notes">
							[SPEAKER NOTES: Esta secci√≥n es sobre herramientas y estrategias para tomar buenas decisiones.]
						</aside>
					</section>

					<!-- Slide 4.2: APMs -->
					<section>
						<h2>1. APMs (Application Performance Monitoring)</h2>
						<p class="fragment">New Relic, Scout, Skylight, etc.</p>
						<p class="fragment">Te muestran el impacto real en producci√≥n</p>
						<pre class="fragment"><code data-trim data-noescape class="language-ruby">
# APM te dice:
# "User.all.each est√° causando 2GB de memory allocations"
# "User.find_each redujo el uso de memoria en 95%"
						</code></pre>
						<aside class="notes">
							[SPEAKER NOTES: Explicar c√≥mo los APMs te dan feedback sobre performance en producci√≥n. Son tu "truth source" sobre qu√© funciona.]
						</aside>
					</section>

					<!-- Slide 4.3: Linters -->
					<section>
						<h2>2. Linters y an√°lisis est√°tico</h2>
						<p class="fragment">RuboCop, Reek, etc.</p>
						<p class="fragment">Detectan problemas antes de que lleguen a producci√≥n</p>
						<pre class="fragment"><code data-trim data-noescape class="language-ruby">
# RuboCop:
# "Use exists? instead of present? for DB existence checks"
# "Avoid all? on potentially empty collections without guard"
						</code></pre>
						<aside class="notes">
							[SPEAKER NOTES: Los linters codifican mejores pr√°cticas de la comunidad. Te gu√≠an hacia patrones idiom√°ticos y seguros.]
						</aside>
					</section>

					<!-- Slide 4.4: Tests -->
					<section>
						<h2>3. Tests autom√°ticos</h2>
						<p class="fragment">Especialmente tests de integraci√≥n y performance</p>
						<pre class="fragment"><code data-trim data-noescape class="language-ruby">
RSpec.describe "User notifications" do
  it "processes large user sets without memory bloat" do
    create_list(:user, 10_000)

    expect {
      UserNotifier.notify_all
    }.to_not exceed_memory_allocation(100.megabytes)
  end
end
						</code></pre>
						<aside class="notes">
							[SPEAKER NOTES: Tests no solo verifican correctitud, tambi√©n pueden verificar performance y uso de recursos.]
						</aside>
					</section>

					<!-- Slide 4.5: Code review y pair programming -->
					<section>
						<h2>4. Revisi√≥n de c√≥digo y colaboraci√≥n</h2>
						<p class="fragment">Code review</p>
						<p class="fragment">Pair programming</p>
						<p class="fragment">Documentaci√≥n del equipo</p>
						<p class="fragment">El conocimiento colectivo gu√≠a las decisiones</p>
						<aside class="notes">
							[SPEAKER NOTES: Las herramientas automatizadas son importantes, pero el criterio humano es irreemplazable. El equipo acumula conocimiento sobre qu√© funciona en su contexto espec√≠fico.]
						</aside>
					</section>

					<!-- Slide 4.6: El contexto importa -->
					<section>
						<h2>El contexto importa</h2>
						<p class="fragment">No hay una "mejor opci√≥n" universal</p>
						<pre class="fragment"><code data-trim data-noescape class="language-ruby">
# Para 10 registros:
User.all.each { ... }  # Est√° bien

# Para 10,000 registros:
User.find_each { ... }  # Necesario

# Para verificar existencia:
User.exists?(email: email)  # Eficiente

# Para usar los datos despu√©s:
User.where(email: email).present?  # Justificado
						</code></pre>
						<aside class="notes">
							[SPEAKER NOTES: La "mejor opci√≥n" depende del volumen de datos, requisitos de performance, legibilidad en contexto, etc.]
						</aside>
					</section>

					<!-- Slide 4.7: Resumen convergencia -->
					<section>
						<h2>Herramientas para converger</h2>
						<p class="fragment">APMs para feedback de producci√≥n</p>
						<p class="fragment">Linters para mejores pr√°cticas</p>
						<p class="fragment">Tests para verificar comportamiento</p>
						<p class="fragment">Revisi√≥n humana para contexto</p>
						<aside class="notes">
							[SPEAKER NOTES: Estas herramientas trabajan juntas para ayudarnos a tomar decisiones informadas.]
						</aside>
					</section>
				</section>

				<!-- ============================================ -->
				<!-- COLUMNA 5: CIERRE                            -->
				<!-- ============================================ -->
				<section>
					<!-- Slide 5.1: Volver al inicio -->
					<section>
						<h2>Volviendo al inicio...</h2>
						<div class="fragment">
							<h3>Yo soy Fernando</h3>
						</div>
						<div class="fragment">
							<h3>Mi nombre es Fernando</h3>
						</div>
						<div class="fragment">
							<h3>Me llamo Fernando</h3>
						</div>
						<aside class="notes">
							[SPEAKER NOTES: Cerrar el c√≠rculo. Retomar las tres formas de presentarse del inicio.]
						</aside>
					</section>

					<!-- Slide 5.2: La elecci√≥n contextual -->
					<section>
						<h2>La elecci√≥n depende del contexto</h2>
						<p class="fragment">Tal vez naturalmente me sale decir "Yo soy Fernando"</p>
						<p class="fragment">Pero hoy, frente a un p√∫blico hispanoparlante en Argentina...</p>
						<p class="fragment">Elijo "Me llamo Fernando"</p>
						<p class="fragment">Y si estuviera en una conferencia internacional en ingl√©s, dir√≠a "I am Fernando"</p>
						<aside class="notes">
							[SPEAKER NOTES: Explicar c√≥mo el contexto (audiencia, formalidad, idioma) determina la mejor opci√≥n. Paralelismo con c√≥digo: el contexto determina qu√© es idiom√°tico.]
						</aside>
					</section>

					<!-- Slide 5.3: Mensaje principal -->
					<section>
						<h2>Lo que nos llevamos</h2>
						<p class="fragment">M√∫ltiples formas de expresar lo mismo = poder</p>
						<p class="fragment">Pero con gran poder viene gran responsabilidad</p>
						<p class="fragment">Elige con criterio, mide, aprende</p>
						<p class="fragment">El c√≥digo idiom√°tico no es "el √∫nico camino", es "el camino apropiado para este contexto"</p>
						<aside class="notes">
							[SPEAKER NOTES: Mensaje de cierre. √ânfasis en que idiomatic != dogm√°tico. Es contextual y pragm√°tico.]
						</aside>
					</section>

					<!-- Slide 5.4: Call to action -->
					<section>
						<h2>¬øPreguntas?</h2>
						<p class="fragment">
							<small>Fernando Silva Jacquier</small><br>
							<small>fesilvajacquier@gmail.com</small><br>
							<small>github.com/fesilvajacquier</small>
						</p>
						<p class="fragment"><small>Referencias y recursos en el repositorio de esta charla</small></p>
						<aside class="notes">
							[SPEAKER NOTES: Abrir Q&A. Estar preparado para preguntas sobre casos espec√≠ficos, herramientas recomendadas, etc.]
						</aside>
					</section>
				</section>

			</div>
		</div>

		<script src="dist/reveal.js"></script>
		<script src="plugin/notes/notes.js"></script>
		<script src="plugin/markdown/markdown.js"></script>
		<script src="plugin/highlight/highlight.js"></script>
		<script>
			// More info about initialization & config:
			// - https://revealjs.com/initialization/
			// - https://revealjs.com/config/
			Reveal.initialize({
				hash: true,

				// Enable fragments for animations
				fragments: true,

				// Show slide numbers
				slideNumber: 'c/t',

				// Show controls
				controls: true,

				// Enable progress bar
				progress: true,

				// Center slides on the screen
				center: true,

				// Transition style
				transition: 'slide', // none/fade/slide/convex/concave/zoom

				// Transition speed
				transitionSpeed: 'default', // default/fast/slow

				// Learn about plugins: https://revealjs.com/plugins/
				plugins: [ RevealMarkdown, RevealHighlight, RevealNotes ]
			});
		</script>
	</body>
</html>
